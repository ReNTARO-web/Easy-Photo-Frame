<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Adobe風 Exif フレームエディタ（Grid/Snap/Text Toolbar）</title>

<script src="https://cdn.jsdelivr.net/npm/exif-js"></script>

<style>
/* AdobeライクなデザインのためのCSS変数 */
:root {
    --adobe-bg: #2b2b2b; /* 暗めの背景色 */
    --adobe-panel: #3c3c3c; /* パネル背景色 */
    --adobe-text: #f0f0f0; /* 明るいテキスト色 */
    --adobe-muted: #9e9e9e; /* ミュートされたテキスト色 */
    --adobe-accent: #007bff; /* 青系アクセント色 (Adobe Blue) */
    --adobe-grid: rgba(255, 255, 255, 0.1); /* グリッド線色 (暗い背景に映える) */
    --adobe-border: #4a4a4a; /* パネルボーダー */
    --adobe-hover: #505050; /* ボタンホバー背景 */
    --adobe-active: #007bff; /* アクティブなボタンの背景 */
    --adobe-shadow: rgba(0, 0, 0, 0.2); /* シャドウ */
    --adobe-font-family: "Segoe UI", "Helvetica Neue", Arial, sans-serif;
}

html, body {
    height: 100%;
    margin: 0;
    font-family: var(--adobe-font-family);
    background: var(--adobe-bg);
    color: var(--adobe-text);
    font-size: 14px;
    line-height: 1.5;
}

.container {
    max-width: 1400px;
    margin: 18px auto;
    padding: 16px;
    display: grid;
    grid-template-columns: 280px 1fr 240px; /* パネル幅を微調整 */
    gap: 16px; /* ギャップを少し広げる */
    align-items: start;
}

.card {
    background: var(--adobe-panel);
    border: 1px solid var(--adobe-border);
    border-radius: 6px; /* 角を少し丸める */
    padding: 15px; /* パディングを増やす */
    box-shadow: 0 4px 12px var(--adobe-shadow); /* シャドウを調整 */
}

.h {
    font-weight: 600; /* フォントウェイトを調整 */
    margin-bottom: 12px;
    color: var(--adobe-text);
    font-size: 16px;
}

.sub-h { /* 小見出し用 */
    font-weight: 500;
    margin-bottom: 8px;
    margin-top: 15px;
    color: var(--adobe-muted);
    font-size: 13px;
    text-transform: uppercase; /* 大文字 */
}

.btn {
    border: 1px solid var(--adobe-border);
    background: var(--adobe-panel);
    padding: 8px 12px;
    border-radius: 4px; /* ボタンの角を丸める */
    cursor: pointer;
    font-size: 13px;
    color: var(--adobe-text);
    transition: background 0.2s, border-color 0.2s, color 0.2s;
    white-space: nowrap; /* テキストが改行されないように */
}

.btn:hover {
    background: var(--adobe-hover);
    border-color: var(--adobe-accent);
    color: var(--adobe-text);
}

.btn.primary {
    background: var(--adobe-accent);
    color: #fff;
    border-color: var(--adobe-accent);
}

.btn.primary:hover {
    background: #0069d9; /* アクティブカラーの少し濃い色 */
    border-color: #0069d9;
}

.btn.active { /* トグルボタンのアクティブ状態 */
    background: var(--adobe-accent);
    color: #fff;
    border-color: var(--adobe-accent);
}

.small {
    font-size: 12px;
    color: var(--adobe-muted);
}

.layer-list {
    max-height: 30vh; /* 少し短く */
    overflow-y: auto;
    background: #333; /* 背景色を追加 */
    border-radius: 4px;
    padding: 5px;
}
.layer-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 6px 8px;
    margin-bottom: 2px;
    border-radius: 4px;
    transition: background 0.2s;
}
.layer-row:hover {
    background: var(--adobe-hover);
}
.layer-row.selected {
    background: rgba(0, 123, 255, 0.3); /* Adobe Blueの薄い背景 */
    border: 1px solid var(--adobe-accent);
}
.layer-row > div {
    display: flex;
    align-items: center;
    gap: 8px;
}
.layer-row input[type="checkbox"] {
    transform: scale(0.9);
}
.layer-row .btn {
    padding: 4px 8px;
    font-size: 12px;
    border: none;
    background: none;
    color: var(--adobe-muted);
}
.layer-row .btn:hover {
    color: var(--adobe-text);
    background: #444;
}


.canvas-area {
    display: flex;
    flex-direction: column;
    gap: 12px; /* ギャップを調整 */
    align-items: center;
}

.frame-box {
    position: relative;
    border-radius: 8px;
    overflow: hidden;
    background: var(--adobe-bg); /* キャンバス背景 */
    box-shadow: 0 8px 28px var(--adobe-shadow);
    border: 1px solid var(--adobe-border); /* キャンバスの枠 */
}

.canvas-inner {
    position: relative;
    left: 0;
    top: 0;
    transform-origin: top left;
}

/* グリッド線のスタイル調整 */
.grid-bg {
    background-image: linear-gradient(to right, var(--adobe-grid) 1px, transparent 1px), 
                      linear-gradient(to bottom, var(--adobe-grid) 1px, transparent 1px);
}

.layer-item {
    position: absolute;
    box-sizing: border-box;
    user-select: none;
    /* transition: left 0.05s, top 0.05s, width 0.05s, height 0.05s; */ /* スムーズな移動・リサイズ */
}
.layer-item.selection {
    outline: 2px solid var(--adobe-accent); /* 選択枠の色と太さ */
    box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.2) inset; /* 選択枠の内側シャドウ */
}
.handle {
    position: absolute;
    width: 10px; /* ハンドルサイズを少し小さく */
    height: 10px;
    background: var(--adobe-accent);
    border-radius: 2px; /* ハンドルの角を丸める */
    border: 1px solid #fff; /* ハンドルのボーダー */
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    z-index: 999;
}
.handle.hidden {
    display: none;
}
.handle.br {
    right: -5px; /* ハンドルの位置調整 */
    bottom: -5px;
    cursor: se-resize;
}
.text-layer {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    white-space: pre-wrap;
    text-align: center;
    pointer-events: none;
    word-break: break-word; /* 長い単語の改行 */
    padding: 5px; /* テキストレイヤー内のパディング */
}

/* テキスト編集時のtextareaスタイル */
.editing {
    background: rgba(255, 255, 255, 0.9);
    border: 1px solid var(--adobe-accent);
    color: #333;
    padding: 5px;
    resize: none;
    box-sizing: border-box;
    font-family: var(--adobe-font-family);
    outline: none;
    z-index: 100;
}

/* ツールバーのスタイル */
.toolbar {
    position: fixed;
    right: 18px;
    top: 18px;
    background: var(--adobe-panel);
    border: 1px solid var(--adobe-border);
    padding: 10px;
    border-radius: 6px;
    box-shadow: 0 4px 12px var(--adobe-shadow);
    width: 220px;
    z-index: 2000;
}
.toolbar .row {
    display: flex;
    gap: 6px; /* ボタン間のギャップを調整 */
    align-items: center;
    margin-bottom: 8px;
}
.toolbar .btn { /* ツールバー内のボタンは少し小さめ */
    padding: 6px 8px;
    min-width: 28px; /* 最小幅を設定 */
    justify-content: center;
}
.toolbar input[type="color"] {
    padding: 2px;
    border: 1px solid var(--adobe-border);
    background: var(--adobe-panel);
    height: 28px;
    width: 40px;
    border-radius: 4px;
}
.toolbar input[type="number"],
.toolbar select {
    background: #4a4a4a;
    border: 1px solid var(--adobe-border);
    color: var(--adobe-text);
    padding: 6px 8px;
    border-radius: 4px;
    font-size: 13px;
    outline: none;
    -webkit-appearance: none; /* デフォルトのスタイルを無効化 */
    -moz-appearance: none;
    appearance: none;
    width: auto; /* widthを調整 */
}
.toolbar select {
    flex: 1;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 8px center;
    background-size: 14px;
    padding-right: 28px;
}
.toolbar label {
    font-size: 13px;
    color: var(--adobe-muted);
    white-space: nowrap;
}

.preset {
    padding: 6px 10px;
    border-radius: 4px;
    border: 1px solid var(--adobe-border);
    background: #4a4a4a;
    color: var(--adobe-text);
    cursor: pointer;
    font-size: 13px;
}
.preset.active, .preset:hover {
    background: var(--adobe-accent);
    color: #fff;
    border-color: var(--adobe-accent);
}

.small-note {
    font-size: 11px;
    color: var(--adobe-muted);
    margin-top: 5px;
}

/* ガイド線 */
.guide-v, .guide-h {
    background: rgba(0, 123, 255, 0.7) !important; /* アクティブなガイド色 */
    z-index: 99;
}


@media (max-width:1100px){
    .container{
        grid-template-columns:1fr;
        gap: 12px;
        padding: 12px;
    }
    .toolbar{
        position:fixed;
        right:12px;
        top:auto;
        bottom:12px;
        width:220px;
        box-shadow: 0 -4px 12px var(--adobe-shadow);
    }
    .card {
        padding: 12px;
    }
    .canvas-area {
        max-width: 100%;
        overflow-x: auto;
    }
}
</style>
</head>
<body>
<div class="container">

  <div class="card">
    <div class="h">ツールパネル</div>

    <div style="margin-bottom:15px">
      <label class="btn">画像追加 <input id="fileInput" type="file" accept="image/*" multiple style="display:none"></label>
      <button id="addTextBtn" class="btn" style="margin-left:8px">テキスト追加</button>
    </div>

    <div class="sub-h">キャンバスサイズ</div>
    <div id="presetRow" style="display:flex;flex-wrap:wrap;gap:8px;margin-top:6px; margin-bottom:15px"></div>

    <div class="sub-h">表示オプション</div>
    <div style="margin-bottom:15px">
      <label style="display:block; margin-bottom: 5px;"><input id="gridToggle" type="checkbox" checked> グリッド表示</label>
      <label style="display:block; margin-bottom: 5px;"><input id="snapToggle" type="checkbox" checked> スナップ有効</label>
      <label style="display:block;"><input id="handlesToggle" type="checkbox" checked> ハンドル表示（UIのみ）</label>
      <div class="small-note">※ 書き出し時はハンドルは含まれません。</div>
    </div>

    <div class="sub-h">フォント</div>
    <div style="margin-bottom:15px">
      <input id="fontInput" type="file" accept=".woff,.woff2,.ttf,.otf" style="width: 100%;">
      <div class="small-note">※ アップロードしたフォントは即 UI に適用され、書き出しにも反映されます。</div>
    </div>

    <div class="sub-h">レイヤー</div>
    <div id="layerList" class="layer-list"></div>

    <div class="sub-h">書き出し</div>
    <div style="margin-top:6px; display:flex;gap:8px;align-items:center;">
      <select id="fmt" class="btn" style="flex:1; padding: 7px 10px;"><option value="png">PNG</option><option value="jpeg">JPEG</option><option value="webp">WebP</option></select>
      <select id="scale" class="btn" style="flex:1; padding: 7px 10px;"><option value="1">1x</option><option value="2">2x</option><option value="3">3x</option></select>
      <button id="exportBtn" class="btn primary">書き出し</button>
    </div>
  </div>

  <div class="card canvas-area" style="align-items:center; justify-content:center;">
    <div style="display:flex;justify-content:space-between;width:100%; margin-bottom: 10px;">
      <div id="canvasInfo" class="small">キャンバス</div>
      <div class="small">操作：ドラッグ / 角ハンドルでリサイズ（Shiftで等比） / ダブルクリックでテキスト編集</div>
    </div>

    <div id="frameBox" class="frame-box" style="width:800px;height:800px;">
      <div id="canvasInner" class="canvas-inner" style="width:800px;height:800px;"></div>
    </div>
  </div>

  <div id="toolbar" class="toolbar" style="display:none">
    <div class="h" style="margin-bottom: 12px; font-size: 15px;">テキストプロパティ</div>
    <div class="row">
      <button id="tbBold" class="btn">B</button>
      <button id="tbItalic" class="btn">I</button>
      <button id="tbUnderline" class="btn">U</button>
    </div>
    <div class="row">
      <label class="small">サイズ</label>
      <input id="tbSize" type="number" min="6" max="200" value="22">
    </div>
    <div class="row">
      <label class="small">色</label>
      <input id="tbColor" type="color" value="#FFFFFF">
    </div>
    <div class="row">
      <label class="small">フォント</label>
      <select id="fontSelect">
        <option value="">システムフォント</option>
      </select>
    </div>
    <div class="row">
      <button id="alignLeft" class="btn">左</button>
      <button id="alignCenter" class="btn">中</button>
      <button id="alignRight" class="btn">右</button>
    </div>
    <div style="margin-top:15px; text-align: right;"><button id="tbApply" class="btn primary">適用</button></div>
  </div>

</div>

<script>
(() => {
  // Config
  const PRESETS = [
    {key:'instagram', label:'1:1', w:1080, h:1080},
    {key:'story', label:'9:16', w:1080, h:1920},
    {key:'x', label:'16:9', w:1920, h:1080},
    {key:'youtube', label:'YouTube', w:1280, h:720},
    {key:'facebook', label:'Facebook', w:1200, h:630},
  ];
  let canvasW = 1080, canvasH = 1080;
  let displayScale = 1;
  let gridOn = true, snapOn = true, handlesVisible = true;
  let gridSize = 54; // グリッドサイズをデフォルトの半分に (1080 / 20)
  const SNAP_RANGE = 10; // px threshold for snap
  let shiftDown = false;
  let loadedFontName = null;

  // Layers state
  let layers = []; // {id,type('photo'|'text'),name,visible,x,y,width,height,url,text,fontSize,lineHeight,align,color,bold,italic,underline}
  let selectedId = null;
  let editingId = null;

  // DOM refs
  const fileInput = document.getElementById('fileInput');
  const addTextBtn = document.getElementById('addTextBtn');
  const presetRow = document.getElementById('presetRow');
  const frameBox = document.getElementById('frameBox');
  const canvasInner = document.getElementById('canvasInner');
  const canvasInfo = document.getElementById('canvasInfo');
  const gridToggle = document.getElementById('gridToggle');
  const snapToggle = document.getElementById('snapToggle');
  const handlesToggle = document.getElementById('handlesToggle');
  const fontInput = document.getElementById('fontInput');
  const exportBtn = document.getElementById('exportBtn');
  const fmtSel = document.getElementById('fmt');
  const scaleSel = document.getElementById('scale');
  const layerList = document.getElementById('layerList');

  // toolbar refs
  const toolbar = document.getElementById('toolbar');
  const tbBold = document.getElementById('tbBold');
  const tbItalic = document.getElementById('tbItalic');
  const tbUnderline = document.getElementById('tbUnderline');
  const tbSize = document.getElementById('tbSize');
  const tbColor = document.getElementById('tbColor');
  const fontSelect = document.getElementById('fontSelect');
  const alignLeft = document.getElementById('alignLeft');
  const alignCenter = document.getElementById('alignCenter');
  const alignRight = document.getElementById('alignRight');
  const tbApply = document.getElementById('tbApply');

  // Init UI
  function init() {
    // presets
    PRESETS.forEach(p => {
      const b = document.createElement('button');
      b.className = 'preset';
      b.textContent = p.label;
      b.onclick = () => setPreset(p.key);
      if (p.key === 'instagram') b.classList.add('active');
      presetRow.appendChild(b);
    });

    fileInput.addEventListener('change', onFiles);
    addTextBtn.addEventListener('click', () => createTextLayer('ダブルクリックで編集'));
    gridToggle.addEventListener('change', (e) => { gridOn = e.target.checked; renderCanvas(); });
    snapToggle.addEventListener('change', (e) => { snapOn = e.target.checked; });
    handlesToggle.addEventListener('change', (e) => { handlesVisible = e.target.checked; renderCanvas(); });
    fontInput.addEventListener('change', onFontFile);
    exportBtn.addEventListener('click', () => exportImage(fmtSel.value, parseFloat(scaleSel.value)));

    tbBold.addEventListener('click', () => toggleTool('bold'));
    tbItalic.addEventListener('click', () => toggleTool('italic'));
    tbUnderline.addEventListener('click', () => toggleTool('underline'));
    alignLeft.addEventListener('click', () => setAlignment('left'));
    alignCenter.addEventListener('click', () => setAlignment('center'));
    alignRight.addEventListener('click', () => setAlignment('right'));
    tbApply.addEventListener('click', applyToolbar);

    window.addEventListener('keydown', (e) => { if (e.key === 'Shift') shiftDown = true; });
    window.addEventListener('keyup', (e) => { if (e.key === 'Shift') shiftDown = false; });

    window.addEventListener('resize', updateScale);

    // default preset
    setPreset('instagram');
    // add fontSelect default
    addFontOption('システムフォント', '');
  }

  function setPreset(key) {
    const p = PRESETS.find(x => x.key === key);
    if (!p) return;
    canvasW = p.w; canvasH = p.h;
    // 短い辺を20分割してグリッドサイズを設定 (要求に応じて2倍細かく)
    gridSize = Math.min(canvasW, canvasH) / 20; // 10分割から20分割に変更

    // mark active
    Array.from(presetRow.children).forEach(b => b.classList.toggle('active', b.textContent === p.label));
    updateScale();
    // snap existing layers to new frame edges/center
    layers = layers.map(l => computeSnapRect(l));
    renderCanvas();
  }

  function updateScale() {
    const maxW = Math.round(window.innerWidth * 0.72);
    const maxH = Math.round(window.innerHeight * 0.78);
    displayScale = Math.min(1, maxW / canvasW, maxH / canvasH) || 1;
    frameBox.style.width = (canvasW * displayScale) + 'px';
    frameBox.style.height = (canvasH * displayScale) + 'px';
    canvasInner.style.width = canvasW + 'px';
    canvasInner.style.height = canvasH + 'px';
    canvasInner.style.transform = `scale(${displayScale})`;
    canvasInfo.textContent = `キャンバス — ${canvasW} × ${canvasH} (表示 ${Math.round(displayScale*100)}%)`;
  }

  // Files -> add photo layer + exif text
  function onFiles(e) {
    const files = Array.from(e.target.files || []);
    files.forEach(file => {
      if (!file.type.startsWith('image/')) return;
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => {
        // 画像をフレームに収まるように拡大（object-fit: contain の挙動）
        // 初期配置はキャンバス全体にフィットさせ、ユーザーがリサイズできるようにする
        const layer = { id: uid(), type: 'photo', name: 'Photo', visible: true, x: 0, y: 0, width: canvasW, height: canvasH, url, objectFit: 'contain' };
        layers.push(layer);

        // EXIF text
        try {
          EXIF.getData(file, function () {
            const make = EXIF.getTag(this, 'Make') || '';
            const model = EXIF.getTag(this, 'Model') || '';
            const lensModel = EXIF.getTag(this, 'LensModel') || ''; // LensModel追加
            const iso = EXIF.getTag(this, 'ISOSpeedRatings') || '';
            const exposure = EXIF.getTag(this, 'ExposureTime') || '';
            const focal = EXIF.getTag(this, 'FocalLength') || '';
            
            const meta = [
              [make, model].filter(Boolean).join(' '),
              lensModel ? `Lens: ${lensModel}` : '', // レンズモデルがあれば表示
              [focal ? `${focal}mm` : '', exposure ? `${exposure}s` : '', iso ? `ISO ${iso}` : ''].filter(Boolean).join(' | ')
            ].filter(Boolean).join('\n');
            
            if (meta) {
              const txW = Math.min(600, canvasW - 80);
              const txX = Math.round((canvasW - txW) / 2);
              const txY = canvasH - 80; // キャンバスの下部に配置（少し余裕を持たせる）
              const tLayer = { id: uid(), type: 'text', name: 'EXIF', visible: true, x: txX, y: txY, width: txW, height: 60, text: meta, fontSize: 18, lineHeight: 1.2, align: 'center', color: '#FFFFFF', boldFirstLine: true };
              layers.push(tLayer);
            }
            renderCanvas();
          });
        } catch (err) {
          renderCanvas();
        }
      };
      img.src = url;
    });
    e.target.value = '';
  }

  function createTextLayer(text = 'ダブルクリックで編集') {
    const w = Math.min(600, canvasW - 80);
    const h = 60;
    const x = Math.round((canvasW - w) / 2);
    const y = Math.round((canvasH - h) / 2);
    const l = { id: uid(), type: 'text', name: 'Text', visible: true, x, y, width: w, height: h, text, fontSize: 22, lineHeight: 1.3, align: 'center', color: '#FFFFFF', bold:false, italic:false, underline:false };
    layers.push(l);
    selectedId = l.id;
    renderCanvas();
  }

  // Render canvas: grid + layers
  function renderCanvas() {
    // clear
    while (canvasInner.firstChild) canvasInner.removeChild(canvasInner.firstChild);
    // grid background
    if (gridOn) {
      canvasInner.classList.add('grid-bg');
      canvasInner.style.backgroundSize = `${gridSize}px ${gridSize}px`;
    } else {
      canvasInner.classList.remove('grid-bg');
      canvasInner.style.backgroundImage = 'none';
    }

    // render layers in order
    layers.forEach((l, idx) => {
      if (!l.visible) return;
      const el = document.createElement('div');
      el.className = 'layer-item';
      el.style.left = l.x + 'px';
      el.style.top = l.y + 'px';
      el.style.width = l.width + 'px';
      el.style.height = l.height + 'px';
      el.dataset.id = l.id;
      if (selectedId === l.id) el.classList.add('selection');

      if (l.type === 'photo') {
        const img = document.createElement('img');
        img.src = l.url;
        img.draggable = false;
        img.style.width = '100%';
        img.style.height = '100%';
        img.style.objectFit = l.objectFit || 'cover'; // objectFitプロパティを考慮
        img.style.pointerEvents = 'none';
        el.appendChild(img);
      } else if (l.type === 'text') {
        const t = document.createElement('div');
        t.className = 'text-layer';
        t.style.width = '100%';
        t.style.height = '100%';
        t.style.fontSize = (l.fontSize || 18) + 'px';
        t.style.lineHeight = (l.lineHeight || 1.3);
        t.style.color = l.color || '#FFFFFF';
        t.style.textAlign = l.align || 'center';
        t.style.fontStyle = l.italic ? 'italic' : 'normal';
        t.style.textDecoration = l.underline ? 'underline' : 'none';
        
        if (loadedFontName) t.style.fontFamily = `"${loadedFontName}", var(--adobe-font-family)`;
        else t.style.fontFamily = `var(--adobe-font-family)`;
        
        const lines = (l.text || '').split('\n');
        
        // Exif text with bold first line
        if(l.name === 'EXIF' && lines.length > 0) { // 最低1行は想定
          const firstLineSpan = document.createElement('span');
          firstLineSpan.textContent = lines[0] || '';
          firstLineSpan.style.fontWeight = '700'; // Exifの1行目は常に太字

          t.appendChild(firstLineSpan);
          
          if (lines.length > 1) {
            for (let i = 1; i < lines.length; i++) {
                const otherLineSpan = document.createElement('span');
                otherLineSpan.textContent = lines[i];
                // 個別のスタイルは適用しないが、全体のテキストレイヤーのスタイルは引き継ぐ
                t.appendChild(document.createElement('br')); // 改行を追加
                t.appendChild(otherLineSpan);
            }
          }

        } else {
          t.textContent = l.text || '';
          t.style.fontWeight = l.bold ? '700' : '400';
        }
        
        t.addEventListener('dblclick', (ev) => { ev.stopPropagation(); startTextEdit(l); });
        el.appendChild(t);
      }

      // pointerdown for select & drag
      el.addEventListener('pointerdown', (ev) => {
        ev.stopPropagation();
        selectLayer(l.id);
        startDrag(ev, l.id);
      });

      // handles (UI only) - single br handle bottom-right
      const handle = document.createElement('div');
      handle.className = 'handle br' + (handlesVisible ? '' : ' hidden');
      handle.addEventListener('pointerdown', (ev) => { ev.stopPropagation(); startResize(ev, l.id); });
      el.appendChild(handle);

      canvasInner.appendChild(el);
    });

    renderLayerList();
    updateToolbarVisibility();
  }

  function renderLayerList() {
    layerList.innerHTML = '';
    // レイヤーを逆順に表示（最新が上に）
    layers.slice().reverse().forEach(l => {
      const row = document.createElement('div');
      row.className = 'layer-row' + (selectedId === l.id ? ' selected' : '');
      row.style.justifyContent = 'space-between';
      row.style.alignItems = 'center';

      const left = document.createElement('div');
      left.style.display = 'flex';
      left.style.alignItems = 'center';
      left.style.gap = '8px';
      const chk = document.createElement('input'); chk.type = 'checkbox'; chk.checked = !!l.visible;
      chk.addEventListener('change', (e) => { e.stopPropagation(); l.visible = chk.checked; renderCanvas(); });
      const label = document.createElement('div'); label.textContent = `${l.name || l.type}`;
      left.appendChild(chk); left.appendChild(label);

      const right = document.createElement('div');
      right.style.display = 'flex'; right.style.gap = '6px';
      // レイヤー選択ボタンを削除し、行全体クリックで選択
      // const sel = document.createElement('button'); sel.className = 'btn'; sel.textContent = '選択';
      // sel.addEventListener('click', (e) => { e.stopPropagation(); selectedId = l.id; renderCanvas(); });
      const del = document.createElement('button'); del.className = 'btn'; del.textContent = '削除';
      del.addEventListener('click', (e) => { e.stopPropagation(); deleteLayer(l.id); });
      // right.appendChild(sel);
      right.appendChild(del);

      row.appendChild(left); row.appendChild(right);
      row.addEventListener('click', (ev) => {
        // const multi = ev.ctrlKey || ev.metaKey || ev.shiftKey;
        // if (!multi) selectedId = l.id;
        selectedId = l.id; // 行クリックで単一選択
        renderCanvas();
      });

      layerList.appendChild(row);
    });
  }

  function uid() { return Date.now().toString(36) + Math.random().toString(36).slice(2, 8); }
  function deleteLayer(id) { layers = layers.filter(x => x.id !== id); if (selectedId === id) selectedId = null; renderCanvas(); }

  /* ---------- Pointer / Drag / Resize ---------- */

  function clientToLocal(e) {
    const rect = canvasInner.getBoundingClientRect();
    return { x: (e.clientX - rect.left) / displayScale, y: (e.clientY - rect.top) / displayScale };
  }

  let dragState = null;

  function startDrag(ev, id) {
    // starts moving primary id only
    const pt = clientToLocal(ev);
    const layer = layers.find(l => l.id === id);
    if (!layer) return;
    const start = { x: pt.x, y: pt.y };
    const origin = JSON.parse(JSON.stringify(layer)); // copy
    dragState = { type: 'drag', id, start, origin, startLayers: JSON.parse(JSON.stringify(layers)) };

    function onMove(e) {
      if (!dragState) return;
      const p = clientToLocal(e);
      const dx = p.x - dragState.start.x;
      const dy = p.y - dragState.start.y;
      const attempt = { ...dragState.origin, x: dragState.origin.x + dx, y: dragState.origin.y + dy };
      const snapped = computeSnapRect(attempt);
      // apply to that layer
      layers = layers.map(l => l.id === id ? { ...l, x: snapped.x, y: snapped.y } : l);
      renderCanvas();
      showGuides(snapped);
    }
    function onUp() { dragState = null; removeGuides(); window.removeEventListener('pointermove', onMove); window.removeEventListener('pointerup', onUp); }
    window.addEventListener('pointermove', onMove);
    window.addEventListener('pointerup', onUp);
  }

  function startResize(ev, id) {
    ev.preventDefault();
    const pt = clientToLocal(ev);
    const base = layers.find(l => l.id === id);
    if (!base) return;
    const origin = JSON.parse(JSON.stringify(base));
    dragState = { type: 'resize', id, startX: pt.x, startY: pt.y, origin, aspect: origin.width / origin.height };

    function onMove(e) {
      if (!dragState) return;
      const p = clientToLocal(e);
      const dx = p.x - dragState.startX;
      const dy = p.y - dragState.startY;
      let nw = Math.max(10, dragState.origin.width + dx);
      let nh = Math.max(8, dragState.origin.height + dy);
      if (shiftDown) { nh = Math.max(8, Math.round(nw / dragState.aspect)); }
      const attempt = { ...dragState.origin, width: nw, height: nh };
      const snapped = computeSnapRect(attempt);
      layers = layers.map(l => l.id === id ? { ...l, width: snapped.width, height: snapped.height } : l);
      renderCanvas();
      showGuides(snapped);
    }

    function onUp() { dragState = null; removeGuides(); window.removeEventListener('pointermove', onMove); window.removeEventListener('pointerup', onUp); }
    window.addEventListener('pointermove', onMove);
    window.addEventListener('pointerup', onUp);
  }

  /* ---------- Snap logic (grid + frame + other layers edges/centers) ---------- */
  function computeSnapRect(moving) {
    if (!snapOn) return clampRect(moving);

    const targetsX = new Set([0, canvasW / 2, canvasW]);
    const targetsY = new Set([0, canvasH / 2, canvasH]);

    // add grid intersections
    for (let gx = 0; gx <= canvasW; gx += gridSize) targetsX.add(gx);
    for (let gy = 0; gy <= canvasH; gy += gridSize) targetsY.add(gy);

    // add other layers edges/centers
    layers.forEach(l => {
      if (!l.visible) return;
      if (l.id === moving.id) return;
      targetsX.add(l.x);
      targetsX.add(l.x + l.width / 2);
      targetsX.add(l.x + l.width);
      targetsY.add(l.y);
      targetsY.add(l.y + l.height / 2);
      targetsY.add(l.y + l.height);
    });

    // candidate positions for moving
    const L = moving.x;
    const CX = moving.x + moving.width / 2;
    const R = moving.x + moving.width;
    const T = moving.y;
    const CY = moving.y + moving.height / 2;
    const B = moving.y + moving.height;

    // find nearest within SNAP_RANGE for each edge type, choose best
    function nearest(val, set) {
      let best = null, bd = Infinity;
      for (const t of set) {
        const d = Math.abs(val - t);
        if (d < bd) { bd = d; best = t; }
      }
      return bd <= SNAP_RANGE ? { v: best, d: bd } : null;
    }

    const nxL = nearest(L, targetsX);
    const nxC = nearest(CX, targetsX);
    const nxR = nearest(R, targetsX);
    const nyT = nearest(T, targetsY);
    const nyC = nearest(CY, targetsY);
    const nyB = nearest(B, targetsY);

    // choose nearest among x edges
    let outX = moving.x;
    let bestXDist = Infinity;
    if (nxL && nxL.d < bestXDist) { outX = moving.x + (nxL.v - L); bestXDist = nxL.d; }
    if (nxC && nxC.d < bestXDist) { outX = moving.x + (nxC.v - CX); bestXDist = nxC.d; }
    if (nxR && nxR.d < bestXDist) { outX = moving.x + (nxR.v - R); bestXDist = nxR.d; }

    // choose nearest among y edges
    let outY = moving.y;
    let bestYDist = Infinity;
    if (nyT && nyT.d < bestYDist) { outY = moving.y + (nyT.v - T); bestYDist = nyT.d; }
    if (nyC && nyC.d < bestYDist) { outY = moving.y + (nyC.v - CY); bestYDist = nyC.d; }
    if (nyB && nyB.d < bestYDist) { outY = moving.y + (nyB.v - B); bestYDist = nyB.d; }

    // clamp width/height to integers
    const outW = Math.max(1, Math.round(moving.width));
    const outH = Math.max(1, Math.round(moving.height));

    return clampRect({ ...moving, x: outX, y: outY, width: outW, height: outH });
  }

  function clampRect(r) {
    const w = Math.max(1, Math.round(r.width));
    const h = Math.max(1, Math.round(r.height));
    let x = Math.round(r.x), y = Math.round(r.y);
    x = Math.max(0, Math.min(x, canvasW - w));
    y = Math.max(0, Math.min(y, canvasH - h));
    return { ...r, x, y, width: w, height: h };
  }

  /* ---------- Guides (visual) ---------- */
  function removeGuides() {
    const gs = frameBox.querySelectorAll('.guide-v, .guide-h');
    gs.forEach(n => n.remove());
  }
  function showGuides(rect) {
    removeGuides();
    const pxs = [rect.x, rect.x + rect.width / 2, rect.x + rect.width, canvasW / 2];
    const pys = [rect.y, rect.y + rect.height / 2, rect.y + rect.height, canvasH / 2];
    pxs.forEach(px => {
      const v = document.createElement('div'); v.className = 'guide-v'; v.style.left = (px) + 'px'; v.style.top = '0px'; v.style.bottom = '0px';
      v.style.position = 'absolute'; v.style.width = '1px'; v.style.background = '#60a5fa'; v.style.opacity = '0.9';
      frameBox.appendChild(v);
    });
    pys.forEach(py => {
      const h = document.createElement('div'); h.className = 'guide-h'; h.style.top = (py) + 'px'; h.style.left = '0px'; h.style.right = '0px';
      h.style.position = 'absolute'; h.style.height = '1px'; h.style.background = '#60a5fa'; h.style.opacity = '0.9';
      frameBox.appendChild(h);
    });
  }

  /* ---------- Text editing (overlay) ---------- */
  function startTextEdit(layer) {
    if (!layer) return;
    editingId = layer.id;
    // create textarea overlay
    const ta = document.createElement('textarea');
    ta.className = 'editing';
    ta.value = layer.text || '';
    ta.style.position = 'absolute';
    ta.style.left = (layer.x) + 'px';
    ta.style.top = (layer.y) + 'px';
    ta.style.width = layer.width + 'px';
    ta.style.height = layer.height + 'px';
    ta.style.fontSize = (layer.fontSize || 18) + 'px';
    ta.style.lineHeight = (layer.lineHeight || 1.3);
    ta.style.textAlign = layer.align || 'center';
    if (loadedFontName) ta.style.fontFamily = `"${loadedFontName}", var(--adobe-font-family)`;
    else ta.style.fontFamily = `var(--adobe-font-family)`;
    ta.style.fontWeight = layer.bold ? '700' : '400';
    ta.style.fontStyle = layer.italic ? 'italic' : 'normal';
    ta.style.textDecoration = layer.underline ? 'underline' : 'none';

    canvasInner.appendChild(ta);
    ta.focus();

    function commit() {
      layer.text = ta.value;
      editingId = null;
      canvasInner.removeChild(ta);
      renderCanvas();
    }
    ta.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); commit(); }
    });
    ta.addEventListener('blur', commit);
  }

  /* ---------- Toolbar (Word-like) ---------- */
  function updateToolbarVisibility() {
    const layer = layers.find(l => l.id === selectedId);
    if (layer && layer.type === 'text') {
      toolbar.style.display = 'block';
      // fill toolbar values
      tbSize.value = layer.fontSize || 22;
      tbColor.value = layer.color || '#FFFFFF'; // Adobe風にデフォルト色を白に
      // font select: try to set loadedFontName if present
      if (loadedFontName) {
        // ensure option exists
        if (![...fontSelect.options].some(o => o.value === loadedFontName)) addFontOption(loadedFontName, loadedFontName);
        fontSelect.value = loadedFontName;
      } else fontSelect.value = '';
      // button states:
      tbBold.classList.toggle('active', !!layer.bold);
      tbItalic.classList.toggle('active', !!layer.italic);
      tbUnderline.classList.toggle('active', !!layer.underline);

      // Align buttons
      alignLeft.classList.toggle('active', layer.align === 'left');
      alignCenter.classList.toggle('active', layer.align === 'center');
      alignRight.classList.toggle('active', layer.align === 'right');

    } else {
      toolbar.style.display = 'none';
    }
  }

  function selectLayer(id) {
    selectedId = id;
    updateToolbarVisibility();
    renderCanvas();
  }

  function toggleTool(kind) {
    const layer = layers.find(l => l.id === selectedId);
    if (!layer || layer.type !== 'text') return;
    if (kind === 'bold') layer.bold = !layer.bold;
    if (kind === 'italic') layer.italic = !layer.italic;
    if (kind === 'underline') layer.underline = !layer.underline;
    renderCanvas();
    updateToolbarVisibility(); // ボタンの状態を更新
  }

  function setAlignment(align) {
    const layer = layers.find(l => l.id === selectedId);
    if (!layer || layer.type !== 'text') return;
    layer.align = align;
    renderCanvas();
    updateToolbarVisibility(); // ボタンの状態を更新
  }

  function applyToolbar() {
    const layer = layers.find(l => l.id === selectedId);
    if (!layer || layer.type !== 'text') return;
    layer.fontSize = parseInt(tbSize.value) || layer.fontSize || 18;
    layer.color = tbColor.value || layer.color;
    const chosenFont = fontSelect.value;
    if (chosenFont) loadedFontName = chosenFont; // set applied font name
    renderCanvas();
  }

  function addFontOption(name, value) {
    if ([...fontSelect.options].some(o => o.value === value)) return;
    const o = document.createElement('option'); o.value = value; o.textContent = name; fontSelect.appendChild(o);
  }

  /* ---------- Font upload ---------- */
  async function onFontFile(e) {
    const f = e.target.files[0];
    if (!f) return;
    const name = f.name.split('.').slice(0, -1).join('-') || 'UploadedFont';
    const url = URL.createObjectURL(f);
    try {
      const font = new FontFace(name, `url(${url})`);
      await font.load();
      document.fonts.add(font);
      loadedFontName = name;
      addFontOption(name, name);
      alert('フォントを読み込みました: ' + name + '\nツールバーで選択してください。');
      renderCanvas();
    } catch (err) {
      console.error(err);
      alert('フォントの読み込みに失敗しました。');
    }
    e.target.value = '';
  }

  /* ---------- Export: offscreen canvas (no handles) ---------- */
  async function exportImage(format = 'png', scale = 2) {
    const W = Math.round(canvasW * scale), H = Math.round(canvasH * scale);
    const cvs = document.createElement('canvas'); cvs.width = W; cvs.height = H;
    const ctx = cvs.getContext('2d');
    ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 0, W, H);

    for (const l of layers) {
      if (!l.visible) continue;
      if (l.type === 'photo') {
        await new Promise(res => {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => {
            if (l.objectFit === 'contain') {
                // 画像をコンテナに収まるように描画
                const imgAspect = img.naturalWidth / img.naturalHeight;
                const canvasAspect = l.width / l.height; // レイヤーの幅と高さを使用

                let drawW = l.width * scale;
                let drawH = l.height * scale;
                let drawX = l.x * scale;
                let drawY = l.y * scale;

                if (imgAspect > canvasAspect) { // 画像が横長
                    drawH = drawW / imgAspect;
                    drawY += (l.height * scale - drawH) / 2;
                } else { // 画像が縦長または正方形
                    drawW = drawH * imgAspect;
                    drawX += (l.width * scale - drawW) / 2;
                }
                ctx.drawImage(img, drawX, drawY, drawW, drawH);
            } else {
                // object-fit: cover のように描画
                ctx.drawImage(img, l.x * scale, l.y * scale, l.width * scale, l.height * scale);
            }
            res();
          };
          img.onerror = () => res();
          img.src = l.url;
        });
      } else if (l.type === 'text') {
        ctx.save();
        const size = Math.round((l.fontSize || 18) * scale);
        ctx.textBaseline = 'top';
        ctx.fillStyle = l.color || '#FFFFFF';
        
        const style = `${l.italic ? 'italic' : 'normal'} ${l.bold ? '700' : '400'} ${size}px`;
        const fontStr = loadedFontName ? `${style} "${loadedFontName}", var(--adobe-font-family)` : `${style} var(--adobe-font-family)`;
        ctx.font = fontStr;

        let y = l.y * scale;
        const lh = Math.round(size * (l.lineHeight || 1.2));
        const lines = (l.text || '').split('\n');
        
        // Handle bold first line for EXIF text
        if(l.name === 'EXIF' && lines.length > 0) {
            const firstLine = lines[0];
            
            // Draw first line bold
            const boldFontStr = loadedFontName ? `${l.italic ? 'italic' : 'normal'} 700 ${size}px "${loadedFontName}", var(--adobe-font-family)` : `${l.italic ? 'italic' : 'normal'} 700 ${size}px var(--adobe-font-family)`;
            ctx.font = boldFontStr;
            ctx.textAlign = l.align || 'center';
            if (l.align === 'center') ctx.fillText(firstLine, (l.x * scale) + (l.width * scale / 2), y);
            else if (l.align === 'left') ctx.fillText(firstLine, l.x * scale, y);
            else ctx.fillText(firstLine, l.x * scale + l.width * scale, y);

            y += lh;
            
            // Draw rest of the text
            ctx.font = fontStr; // Revert to original style
            for(let i=1; i < lines.length; i++) {
                if (l.align === 'center') ctx.fillText(lines[i], (l.x * scale) + (l.width * scale / 2), y);
                else if (l.align === 'left') ctx.fillText(lines[i], l.x * scale, y);
                else ctx.fillText(lines[i], l.x * scale + l.width * scale, y);
                y += lh;
            }

        } else {
            // Normal text rendering
            ctx.textAlign = l.align || 'center';
            for(let i=0; i<lines.length; i++){
                if (l.align === 'center') ctx.fillText(lines[i], (l.x * scale) + (l.width * scale / 2), y);
                else if (l.align === 'left') ctx.fillText(lines[i], l.x * scale, y);
                else ctx.fillText(lines[i], l.x * scale + l.width * scale, y);
                y += lh;
            }
        }

        ctx.restore();
      }
    }

    const dataUrl = cvs.toDataURL(`image/${format}`, 0.9);
    const a = document.createElement('a');
    a.href = dataUrl;
    a.download = `exported_image.${format}`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  }

  // Event handler for canvas outer space click
  document.body.addEventListener('pointerdown', (e) => {
      if (!frameBox.contains(e.target) && !toolbar.contains(e.target)) {
          selectedId = null;
          renderCanvas();
      }
  });

  // initial call
  init();
})();
</script>
</body>
</html>
