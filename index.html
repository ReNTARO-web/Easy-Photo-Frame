<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FRAME EDIT</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/exif-js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&family=Poppins:wght@600&family=Roboto:wght@400&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: #f0f4f8; /* Soft background */
        }
        #app {
            display: flex;
            height: 100vh;
        }
        .sidebar {
            width: 350px;
        }
        .canvas-container {
            position: relative;
            overflow: hidden;
            background-color: #ffffff; /* Clear workspace */
            cursor: default;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08);
            border: 1px solid #e2e8f0;
        }
        .draggable {
            position: absolute;
            box-sizing: border-box;
            border: 2px solid transparent; /* Initially transparent border */
            cursor: grab;
        }
        .draggable.active {
            border-color: #3b82f6; /* Blue border when active */
        }
        .draggable.active .resize-handle {
            display: block;
        }
        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #3b82f6;
            border: 1px solid #ffffff;
            border-radius: 50%;
            display: none;
        }
        .resize-handle.tl { top: -5px; left: -5px; cursor: nwse-resize; }
        .resize-handle.tr { top: -5px; right: -5px; cursor: nesw-resize; }
        .resize-handle.bl { bottom: -5px; left: -5px; cursor: nesw-resize; }
        .resize-handle.br { bottom: -5px; right: -5px; cursor: nwse-resize; }
        .resize-handle.t { top: -5px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        .resize-handle.b { bottom: -5px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        .resize-handle.l { top: 50%; left: -5px; transform: translateY(-50%); cursor: ew-resize; }
        .resize-handle.r { top: 50%; right: -5px; transform: translateY(-50%); cursor: ew-resize; }
        .text-layer {
            cursor: text;
        }
        .layer-item:hover .layer-actions {
            opacity: 1;
        }
        .layer-actions {
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }
        .layer-item.active {
            background-color: #e2e8f0;
        }
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: 25px 25px; /* Adjust grid size */
            background-image: linear-gradient(to right, rgba(0, 0, 0, 0.1) 1px, transparent 1px),
                              linear-gradient(to bottom, rgba(0, 0, 0, 0.1) 1px, transparent 1px);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .canvas-container:hover .grid-overlay {
            opacity: 1;
        }
    </style>
</head>
<body class="bg-gray-100 flex h-screen overflow-hidden">
    <!-- Main application container -->
    <div id="app" class="flex w-full">
        <!-- Sidebar for tools and layers -->
        <div class="sidebar bg-white p-6 shadow-lg flex flex-col justify-between">
            <div>
                <h1 class="text-3xl font-bold mb-6 text-gray-800">FRAME EDIT</h1>

                <!-- Action buttons section -->
                <div class="space-y-4 mb-6">
                    <button id="add-text-btn" class="w-full flex items-center justify-center p-3 rounded-lg bg-blue-500 text-white font-semibold hover:bg-blue-600 transition duration-300 shadow-md">
                        <i class="fa-solid fa-font mr-2"></i> テキストを追加
                    </button>
                    <button id="upload-image-btn" class="w-full flex items-center justify-center p-3 rounded-lg bg-green-500 text-white font-semibold hover:bg-green-600 transition duration-300 shadow-md">
                        <i class="fa-solid fa-image mr-2"></i> 画像をアップロード
                    </button>
                    <input type="file" id="image-upload" class="hidden" accept="image/*">
                </div>
                
                <!-- Aspect Ratio controls -->
                <div class="mb-6">
                    <h2 class="text-lg font-semibold mb-2">アスペクト比</h2>
                    <div class="grid grid-cols-3 gap-2">
                        <button class="aspect-btn p-2 rounded-lg border-2 border-gray-300 text-sm font-medium transition duration-300 hover:bg-gray-200" data-ratio="original">オリジナル</button>
                        <button class="aspect-btn p-2 rounded-lg border-2 border-gray-300 text-sm font-medium transition duration-300 hover:bg-gray-200" data-ratio="16/9">16:9</button>
                        <button class="aspect-btn p-2 rounded-lg border-2 border-gray-300 text-sm font-medium transition duration-300 hover:bg-gray-200" data-ratio="9/16">9:16</button>
                        <button class="aspect-btn p-2 rounded-lg border-2 border-gray-300 text-sm font-medium transition duration-300 hover:bg-gray-200" data-ratio="4/3">4:3</button>
                        <button class="aspect-btn p-2 rounded-lg border-2 border-gray-300 text-sm font-medium transition duration-300 hover:bg-gray-200" data-ratio="3/4">3:4</button>
                        <button class="aspect-btn p-2 rounded-lg border-2 border-gray-300 text-sm font-medium transition duration-300 hover:bg-gray-200" data-ratio="1/1">1:1</button>
                    </div>
                </div>

                <!-- Layers Panel -->
                <div>
                    <h2 class="text-lg font-semibold mb-2">レイヤー</h2>
                    <ul id="layers-list" class="bg-gray-100 p-2 rounded-lg max-h-60 overflow-y-auto">
                        <!-- Layer items will be dynamically added here -->
                    </ul>
                    <button id="ungroup-btn" class="mt-4 w-full p-2 rounded-lg bg-yellow-500 text-white font-semibold hover:bg-yellow-600 transition duration-300 shadow-md">
                        <i class="fa-solid fa-users-slash mr-2"></i> グループを解除
                    </button>
                </div>
            </div>

            <!-- Download button -->
            <div class="mt-6">
                <button id="download-btn" class="w-full flex items-center justify-center p-3 rounded-lg bg-indigo-500 text-white font-semibold hover:bg-indigo-600 transition duration-300 shadow-md">
                    <i class="fa-solid fa-download mr-2"></i> ダウンロード
                </button>
            </div>
        </div>

        <!-- Main canvas area -->
        <div id="canvas-wrapper" class="flex-grow flex items-center justify-center p-6 relative overflow-hidden">
            <div id="canvas-container" class="canvas-container w-full h-full relative flex items-center justify-center">
                 <!-- Grid overlay -->
                <div class="grid-overlay"></div>
                <!-- Layers will be placed here -->
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvasContainer = document.getElementById('canvas-container');
            const addTextBtn = document.getElementById('add-text-btn');
            const uploadImageBtn = document.getElementById('upload-image-btn');
            const imageUploadInput = document.getElementById('image-upload');
            const layersList = document.getElementById('layers-list');
            const downloadBtn = document.getElementById('download-btn');
            const aspectBtns = document.querySelectorAll('.aspect-btn');
            const ungroupBtn = document.getElementById('ungroup-btn');

            let isDragging = false;
            let isResizing = false;
            let resizeHandle = null;
            let activeLayer = null;
            let dragStartX, dragStartY;
            let initialX, initialY, initialWidth, initialHeight, initialLeft, initialTop;
            const GRID_SIZE = 25; // グリッドのサイズを定数として定義

            // グリッドにスナップする関数
            const snapToGrid = (value) => Math.round(value / GRID_SIZE) * GRID_SIZE;

            // Function to generate a unique ID
            const generateId = () => `layer-${Date.now()}-${Math.floor(Math.random() * 1000)}`;

            // --- Layer Management ---

            // Function to create a new layer item in the list
            const createLayerListItem = (layerElement) => {
                const layerId = layerElement.dataset.id;
                const layerType = layerElement.dataset.type;
                const layerIndex = layersList.children.length;
                const layerName = layerType === 'text' ? 'テキスト' : '画像';

                const listItem = document.createElement('li');
                listItem.dataset.id = layerId;
                listItem.classList.add('layer-item', 'flex', 'items-center', 'justify-between', 'p-2', 'rounded-lg', 'cursor-pointer', 'mb-1', 'transition-colors', 'duration-200');

                // Content for the list item
                listItem.innerHTML = `
                    <div class="flex items-center flex-grow">
                        <i class="fa-solid ${layerType === 'text' ? 'fa-font' : 'fa-image'} text-gray-500 mr-2"></i>
                        <span class="text-sm font-medium text-gray-700">${layerName} ${layerIndex + 1}</span>
                    </div>
                    <div class="layer-actions flex items-center space-x-2">
                        <button class="toggle-visibility-btn p-1 rounded-full text-gray-500 hover:bg-gray-300 transition-colors duration-200" data-visible="true">
                            <i class="fa-solid fa-eye"></i>
                        </button>
                        <button class="delete-layer-btn p-1 rounded-full text-red-500 hover:bg-red-200 transition-colors duration-200">
                            <i class="fa-solid fa-trash-can"></i>
                        </button>
                    </div>
                `;

                // Event listener for selecting the layer from the list
                listItem.addEventListener('click', (e) => {
                    if (e.target.closest('.layer-actions')) return; // Ignore clicks on action buttons
                    selectLayer(layerElement);
                });

                // Event listener for toggling visibility
                listItem.querySelector('.toggle-visibility-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isVisible = layerElement.style.display !== 'none';
                    layerElement.style.display = isVisible ? 'none' : 'block';
                    e.currentTarget.dataset.visible = !isVisible;
                    e.currentTarget.innerHTML = `<i class="fa-solid fa-${isVisible ? 'eye-slash' : 'eye'}"></i>`;
                });

                // Event listener for deleting the layer
                listItem.querySelector('.delete-layer-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    layerElement.remove();
                    listItem.remove();
                    if (activeLayer === layerElement) {
                        activeLayer = null;
                    }
                    updateLayersList();
                });

                return listItem;
            };

            // Function to update the layers list in the UI
            const updateLayersList = () => {
                layersList.innerHTML = '';
                const layers = Array.from(canvasContainer.children).filter(el => el.classList.contains('draggable')).reverse(); // Reverse to match Z-index
                layers.forEach(layer => {
                    const listItem = createLayerListItem(layer);
                    layersList.appendChild(listItem);
                    if (layer === activeLayer) {
                        listItem.classList.add('active');
                    }
                });
            };

            // Function to select a layer and make it active
            const selectLayer = (layer) => {
                if (activeLayer) {
                    activeLayer.classList.remove('active');
                    removeResizeHandles();
                    if (activeLayer.classList.contains('text-layer')) {
                        activeLayer.contentEditable = 'false';
                        activeLayer.blur();
                    }
                }
                activeLayer = layer;
                activeLayer.classList.add('active');
                createResizeHandles();
                if (activeLayer.classList.contains('text-layer')) {
                    activeLayer.contentEditable = 'true';
                }

                // Update the layers list UI
                document.querySelectorAll('.layer-item').forEach(item => {
                    item.classList.remove('active');
                    if (item.dataset.id === activeLayer.dataset.id) {
                        item.classList.add('active');
                    }
                });
            };

            // --- Drag & Resize Functionality ---

            const createResizeHandles = () => {
                if (!activeLayer) return;
                const handles = ['tl', 't', 'tr', 'l', 'r', 'bl', 'b', 'br'];
                handles.forEach(pos => {
                    const handle = document.createElement('div');
                    handle.classList.add('resize-handle', pos);
                    activeLayer.appendChild(handle);
                });
            };

            const removeResizeHandles = () => {
                if (activeLayer) {
                    const handles = activeLayer.querySelectorAll('.resize-handle');
                    handles.forEach(handle => handle.remove());
                }
            };

            const getLayerInfo = (layer) => {
                const rect = layer.getBoundingClientRect();
                return {
                    x: rect.left,
                    y: rect.top,
                    width: rect.width,
                    height: rect.height,
                    left: layer.offsetLeft,
                    top: layer.offsetTop
                };
            };

            // --- Event Listeners ---

            // Add Text Layer
            addTextBtn.addEventListener('click', () => {
                const layerId = generateId();
                const newTextLayer = document.createElement('div');
                newTextLayer.classList.add('draggable', 'text-layer', 'p-0', 'bg-transparent', 'hover:bg-gray-200', 'transition-colors', 'duration-200', 'text-black');
                newTextLayer.style.left = '50px';
                newTextLayer.style.top = '50px';
                newTextLayer.style.minWidth = '50px';
                newTextLayer.style.minHeight = '30px';
                newTextLayer.style.fontFamily = 'Roboto, sans-serif';
                newTextLayer.style.fontSize = '14px'; // Change to 14px
                newTextLayer.style.cursor = 'grab';
                newTextLayer.dataset.type = 'text';
                newTextLayer.dataset.id = layerId;
                newTextLayer.innerText = '新しいテキスト';
                newTextLayer.contentEditable = 'true';
                canvasContainer.appendChild(newTextLayer);
                selectLayer(newTextLayer);
                updateLayersList();
                newTextLayer.focus();
            });

            // Upload Image
            uploadImageBtn.addEventListener('click', () => imageUploadInput.click());
            imageUploadInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        // Create a group container for the image and text
                        const groupContainer = document.createElement('div');
                        groupContainer.classList.add('draggable', 'group-layer');
                        groupContainer.dataset.type = 'group';
                        groupContainer.dataset.id = generateId();
                        groupContainer.style.position = 'absolute';
                        groupContainer.style.display = 'flex';
                        groupContainer.style.flexDirection = 'column';
                        groupContainer.style.alignItems = 'center';
                        groupContainer.style.justifyContent = 'center';

                        const newImageLayer = document.createElement('div');
                        newImageLayer.classList.add('image-layer');
                        newImageLayer.dataset.type = 'image';
                        newImageLayer.dataset.id = generateId();
                        newImageLayer.style.width = '100%';
                        newImageLayer.style.height = '100%';

                        const imgElement = document.createElement('img');
                        imgElement.src = event.target.result;
                        imgElement.style.width = '100%';
                        imgElement.style.height = '100%';
                        imgElement.style.objectFit = 'contain';
                        imgElement.style.pointerEvents = 'none';
                        newImageLayer.appendChild(imgElement);
                        groupContainer.appendChild(newImageLayer);

                        // Set initial size based on canvas ratio
                        const canvasRatio = canvasContainer.clientWidth / canvasContainer.clientHeight;
                        const imageRatio = img.naturalWidth / img.naturalHeight;
                        if (imageRatio > canvasRatio) {
                            groupContainer.style.width = '70%';
                            groupContainer.style.height = `${(canvasContainer.clientWidth * 0.7) / imageRatio}px`;
                        } else {
                            groupContainer.style.height = '70%';
                            groupContainer.style.width = `${(canvasContainer.clientHeight * 0.7) * imageRatio}px`;
                        }

                        // Extract and display EXIF data
                        try {
                            EXIF.getData(file, function() {
                                const cameraMake = EXIF.getTag(this, "Make");
                                const cameraModel = EXIF.getTag(this, "Model");
                                const fNumber = EXIF.getTag(this, "FNumber");
                                const exposureTime = EXIF.getTag(this, "ExposureTime");
                                const iso = EXIF.getTag(this, "ISOSpeedRatings");
                                
                                const exifTextLayer = document.createElement('div');
                                exifTextLayer.classList.add('text-layer', 'p-2', 'rounded-lg', 'text-gray-800', 'exif-data');
                                exifTextLayer.dataset.type = 'text';
                                exifTextLayer.dataset.id = generateId();
                                exifTextLayer.contentEditable = 'false';
                                exifTextLayer.style.textAlign = 'center'; // Center the text
                                exifTextLayer.style.marginTop = '10px';
                                exifTextLayer.style.fontFamily = 'Roboto, sans-serif';

                                let exifHtml = '';
                                if (cameraMake || cameraModel) {
                                    exifHtml += `<div class="font-bold text-base mb-1">${cameraMake ? cameraMake + ' ' : ''}${cameraModel || ''}</div>`;
                                }
                                if (fNumber || exposureTime || iso) {
                                    exifHtml += `<div class="text-xs text-gray-500">`;
                                    if (fNumber) exifHtml += `F/${fNumber.numerator / fNumber.denominator} `;
                                    if (exposureTime) {
                                        const exposure = exposureTime.numerator / exposureTime.denominator;
                                        exifHtml += `${exposure >= 1 ? exposure + 's' : `1/${1/exposure}`}s `;
                                    }
                                    if (iso) exifHtml += `ISO ${iso}`;
                                    exifHtml += `</div>`;
                                }

                                if (exifHtml) {
                                    exifTextLayer.innerHTML = exifHtml;
                                    groupContainer.appendChild(exifTextLayer);
                                }
                            });
                        } catch (e) {
                            console.error("EXIFデータの読み込み中にエラーが発生しました:", e);
                        }

                        canvasContainer.appendChild(groupContainer);

                        // Center the group in the canvas
                        groupContainer.style.left = `calc(50% - ${groupContainer.clientWidth / 2}px)`;
                        groupContainer.style.top = `calc(50% - ${groupContainer.clientHeight / 2}px)`;
                        
                        selectLayer(groupContainer);
                        updateLayersList();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            });

            // Aspect Ratio Buttons
            aspectBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    aspectBtns.forEach(b => b.classList.remove('active', 'bg-blue-500', 'text-white'));
                    btn.classList.add('active', 'bg-blue-500', 'text-white');
                    resizeFrame(btn.dataset.ratio);
                });
            });

            // Function to resize the canvas frame
            const resizeFrame = (ratioStr) => {
                const parent = document.getElementById('canvas-wrapper');
                const parentWidth = parent.clientWidth;
                const parentHeight = parent.clientHeight;

                let newWidth, newHeight;
                if (ratioStr === 'original') {
                    // Reset to parent's full dimensions
                    newWidth = parentWidth;
                    newHeight = parentHeight;
                } else {
                    const [widthRatio, heightRatio] = ratioStr.split('/').map(Number);
                    const parentRatio = parentWidth / parentHeight;
                    const desiredRatio = widthRatio / heightRatio;

                    if (desiredRatio > parentRatio) {
                        newWidth = parentWidth;
                        newHeight = parentWidth / desiredRatio;
                    } else {
                        newHeight = parentHeight;
                        newWidth = parentHeight * desiredRatio;
                    }
                }

                canvasContainer.style.width = `${newWidth}px`;
                canvasContainer.style.height = `${newHeight}px`;
                canvasContainer.style.position = 'absolute';
            };

            // Download Button
            downloadBtn.addEventListener('click', () => {
                // Deactivate the active layer and its handles for the download
                if (activeLayer) {
                    activeLayer.classList.remove('active');
                    removeResizeHandles();
                    activeLayer = null;
                }
                const activeRatioBtn = document.querySelector('.aspect-btn.active');
                if(activeRatioBtn) activeRatioBtn.style.outline = 'none';

                const html2canvasScript = document.createElement('script');
                html2canvasScript.src = 'https://html2canvas.hertzen.com/dist/html2canvas.min.js';
                document.body.appendChild(html2canvasScript);

                html2canvasScript.onload = () => {
                    html2canvas(canvasContainer, {
                        scale: 2, // Improve image quality
                        backgroundColor: '#ffffff'
                    }).then(canvas => {
                        const link = document.createElement('a');
                        link.download = 'frame.png';
                        link.href = canvas.toDataURL('image/png');
                        link.click();
                        // Reactivate the layer after download
                        if (activeLayer) {
                            selectLayer(activeLayer);
                        }
                        if(activeRatioBtn) activeRatioBtn.style.outline = 'auto';
                    });
                };
            });

            // グループ解除ボタンの機能
            ungroupBtn.addEventListener('click', () => {
                // 現在アクティブなレイヤーがグループであるかを確認
                if (activeLayer && activeLayer.classList.contains('group-layer')) {
                    const parentGroup = activeLayer;
                    
                    // まず、グループから不要なハンドルを削除
                    removeResizeHandles();

                    // 実際のコンテンツレイヤー（画像とテキスト）のみをフィルタリング
                    const children = Array.from(parentGroup.children).filter(child => 
                        child.classList.contains('image-layer') || child.classList.contains('text-layer')
                    );
                    
                    children.forEach(child => {
                        // 子要素の新しい絶対位置を計算（グループ内の相対位置 + グループの絶対位置）
                        const newLeft = parentGroup.offsetLeft + child.offsetLeft;
                        const newTop = parentGroup.offsetTop + child.offsetTop;

                        // 子要素をキャンバスに直接移動
                        canvasContainer.appendChild(child);
                        child.style.position = 'absolute';
                        child.style.left = `${newLeft}px`;
                        child.style.top = `${newTop}px`;
                        child.classList.add('draggable'); // ドラッグ可能に戻す
                    });
                    
                    parentGroup.remove(); // 空になったグループコンテナを削除
                    
                    if (children.length > 0) {
                      selectLayer(children[0]);
                    } else {
                      activeLayer = null; // If group had no children, deselect
                    }
                    updateLayersList();
                }
            });

            // Global event listeners for drag and resize
            document.addEventListener('mousedown', (e) => {
                const target = e.target;
                if (target.classList.contains('resize-handle')) {
                    isResizing = true;
                    resizeHandle = target.classList[1];
                    const layer = target.closest('.draggable'); // Get the top-level draggable group
                    selectLayer(layer);
                    const info = getLayerInfo(layer);
                    initialX = e.clientX;
                    initialY = e.clientY;
                    initialWidth = info.width;
                    initialHeight = info.height;
                    initialLeft = info.left;
                    initialTop = info.top;
                    document.body.style.cursor = target.style.cursor;
                } else if (target.closest('.draggable')) {
                    const layer = target.closest('.draggable');
                    selectLayer(layer);
                    isDragging = true;
                    dragStartX = e.clientX - layer.offsetLeft;
                    dragStartY = e.clientY - layer.offsetTop;
                    layer.style.cursor = 'grabbing';
                } else if (!target.closest('.sidebar')) {
                    if (activeLayer) {
                        activeLayer.classList.remove('active');
                        removeResizeHandles();
                        activeLayer = null;
                        document.querySelectorAll('.layer-item').forEach(item => item.classList.remove('active'));
                    }
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging && activeLayer) {
                    const newLeft = e.clientX - dragStartX;
                    const newTop = e.clientY - dragStartY;
                    // グリッドにスナップ
                    activeLayer.style.left = `${snapToGrid(newLeft)}px`;
                    activeLayer.style.top = `${snapToGrid(newTop)}px`;
                } else if (isResizing && activeLayer) {
                    const dx = e.clientX - initialX;
                    const dy = e.clientY - initialY;
                    let newWidth = initialWidth;
                    let newHeight = initialHeight;
                    let newLeft = initialLeft;
                    let newTop = initialTop;

                    switch (resizeHandle) {
                        case 'br':
                            newWidth = snapToGrid(initialWidth + dx);
                            newHeight = snapToGrid(initialHeight + dy);
                            break;
                        case 'bl':
                            newWidth = snapToGrid(initialWidth - dx);
                            newHeight = snapToGrid(initialHeight + dy);
                            newLeft = snapToGrid(initialLeft + dx);
                            break;
                        case 'tr':
                            newWidth = snapToGrid(initialWidth + dx);
                            newHeight = snapToGrid(initialHeight - dy);
                            newTop = snapToGrid(initialTop + dy);
                            break;
                        case 'tl':
                            newWidth = snapToGrid(initialWidth - dx);
                            newHeight = snapToGrid(initialHeight - dy);
                            newLeft = snapToGrid(initialLeft + dx);
                            newTop = snapToGrid(initialTop + dy);
                            break;
                        case 't':
                            newHeight = snapToGrid(initialHeight - dy);
                            newTop = snapToGrid(initialTop + dy);
                            break;
                        case 'b':
                            newHeight = snapToGrid(initialHeight + dy);
                            break;
                        case 'l':
                            newWidth = snapToGrid(initialWidth - dx);
                            newLeft = snapToGrid(initialLeft + dx);
                            break;
                        case 'r':
                            newWidth = snapToGrid(initialWidth + dx);
                            break;
                    }

                    if (newWidth > GRID_SIZE) {
                        activeLayer.style.width = `${newWidth}px`;
                        activeLayer.style.left = `${newLeft}px`;
                    }
                    if (newHeight > GRID_SIZE) {
                        activeLayer.style.height = `${newHeight}px`;
                        activeLayer.style.top = `${newTop}px`;
                    }
                }
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
                isResizing = false;
                resizeHandle = null;
                document.body.style.cursor = 'default';
                if (activeLayer && activeLayer.classList.contains('text-layer')) {
                    // Re-enable contentEditable after drag/resize ends
                    activeLayer.contentEditable = 'true';
                }
            });

            // Touch events for mobile
            document.addEventListener('touchstart', (e) => {
                const target = e.target;
                if (target.classList.contains('resize-handle')) {
                    isResizing = true;
                    resizeHandle = target.classList[1];
                    const layer = target.closest('.draggable');
                    selectLayer(layer);
                    const info = getLayerInfo(layer);
                    initialX = e.touches[0].clientX;
                    initialY = e.touches[0].clientY;
                    initialWidth = info.width;
                    initialHeight = info.height;
                    initialLeft = info.left;
                    initialTop = info.top;
                } else if (target.closest('.draggable')) {
                    const layer = target.closest('.draggable');
                    selectLayer(layer);
                    isDragging = true;
                    dragStartX = e.touches[0].clientX - layer.offsetLeft;
                    dragStartY = e.touches[0].clientY - layer.offsetTop;
                } else if (!target.closest('.sidebar')) {
                    if (activeLayer) {
                        activeLayer.classList.remove('active');
                        removeResizeHandles();
                        activeLayer = null;
                        document.querySelectorAll('.layer-item').forEach(item => item.classList.remove('active'));
                    }
                }
            });

            document.addEventListener('touchmove', (e) => {
                if (isDragging && activeLayer) {
                    const newLeft = e.touches[0].clientX - dragStartX;
                    const newTop = e.touches[0].clientY - dragStartY;
                    // グリッドにスナップ
                    activeLayer.style.left = `${snapToGrid(newLeft)}px`;
                    activeLayer.style.top = `${snapToGrid(newTop)}px`;
                } else if (isResizing && activeLayer) {
                    const dx = e.touches[0].clientX - initialX;
                    const dy = e.touches[0].clientY - initialY;
                    let newWidth = initialWidth;
                    let newHeight = initialHeight;
                    let newLeft = initialLeft;
                    let newTop = initialTop;

                    switch (resizeHandle) {
                        case 'br':
                            newWidth = snapToGrid(initialWidth + dx);
                            newHeight = snapToGrid(initialHeight + dy);
                            break;
                        case 'bl':
                            newWidth = snapToGrid(initialWidth - dx);
                            newHeight = snapToGrid(initialHeight + dy);
                            newLeft = snapToGrid(initialLeft + dx);
                            break;
                        case 'tr':
                            newWidth = snapToGrid(initialWidth + dx);
                            newHeight = snapToGrid(initialHeight - dy);
                            newTop = snapToGrid(initialTop + dy);
                            break;
                        case 'tl':
                            newWidth = snapToGrid(initialWidth - dx);
                            newHeight = snapToGrid(initialHeight - dy);
                            newLeft = snapToGrid(initialLeft + dx);
                            newTop = snapToGrid(initialTop + dy);
                            break;
                        case 't':
                            newHeight = snapToGrid(initialHeight - dy);
                            newTop = snapToGrid(initialTop + dy);
                            break;
                        case 'b':
                            newHeight = snapToGrid(initialHeight + dy);
                            break;
                        case 'l':
                            newWidth = snapToGrid(initialWidth - dx);
                            newLeft = snapToGrid(initialLeft + dx);
                            break;
                        case 'r':
                            newWidth = snapToGrid(initialWidth + dx);
                            break;
                    }

                    if (newWidth > GRID_SIZE) {
                        activeLayer.style.width = `${newWidth}px`;
                        activeLayer.style.left = `${newLeft}px`;
                    }
                    if (newHeight > GRID_SIZE) {
                        activeLayer.style.height = `${newHeight}px`;
                        activeLayer.style.top = `${newTop}px`;
                    }
                }
            });

            document.addEventListener('touchend', () => {
                isDragging = false;
                isResizing = false;
                resizeHandle = null;
                document.body.style.cursor = 'default';
                if (activeLayer && activeLayer.classList.contains('text-layer')) {
                    // Re-enable contentEditable after drag/resize ends
                    activeLayer.contentEditable = 'true';
                }
            });

            // Double-click to edit text
            canvasContainer.addEventListener('dblclick', (e) => {
                const target = e.target;
                if (target.classList.contains('text-layer')) {
                    selectLayer(target);
                    target.focus();
                }
            });

            // Initial setup
            resizeFrame('original');
            document.querySelector('[data-ratio="original"]').classList.add('active', 'bg-blue-500', 'text-white');
        });
    </script>
</body>
</html>
